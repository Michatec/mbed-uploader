name: .NET Core Desktop

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    strategy:
      matrix:
        configuration: [Debug, Release]

    runs-on: windows-latest

    env:
      Solution_Name: x86/MbedUploader.sln
      Test_Project_Path: x86/Mbed.Uploader/MbedUploader.csproj
      Build_Output_Directory: x86/Mbed.Uploader/bin
      Directory: x86/Mbed.Uploader

    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
    - name: ğŸ§± Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ğŸ§© Install .NET 8 SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: âš™ï¸ Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2

    - name: ğŸ§ª Run Unit Tests
      run: dotnet test $env:Test_Project_Path --configuration ${{ matrix.configuration }}

    - name: ğŸ”„ Restore Solution
      run: msbuild $env:Solution_Name /t:Restore /p:Configuration=${{ matrix.configuration }}

    - name: ğŸ—ï¸ Build Solution
      run: msbuild $env:Solution_Name /p:Configuration=${{ matrix.configuration }}

    # Optional: Signiere mit deinem PFX-Zertifikat (wenn vorhanden)
    - name: ğŸ” Decode the PFX
      run: |
        $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.Base64_Encoded_Pfx }}")
        $certificatePath = "$env:Build_Output_Directory/license.pfx"
        [IO.File]::WriteAllBytes($certificatePath, $pfx_cert_byte)
      shell: pwsh

    # Optionales App-Packaging (falls du irgendwann ein AppX-Bundle brauchst)
    - name: ğŸ“¦ Create App Package
      run: |
        msbuild $env:Directory `
          /p:Configuration=${{ matrix.configuration }} `
          /p:UapAppxPackageBuildMode=StoreUpload `
          /p:AppxBundle=Always `
          /p:PackageCertificateKeyFile=license.pfx `
          /p:PackageCertificatePassword=${{ secrets.Pfx_Key }}
      shell: pwsh

    - name: ğŸ§¹ Remove the PFX
      run: Remove-Item -Path "$env:Build_Output_Directory/license.pfx"
      shell: pwsh

    - name: ğŸ” Extract Assembly Version
      id: version
      shell: pwsh
      run: |
        $assemblyInfo = Get-ChildItem -Recurse -Filter "AssemblyInfo.cs" | Get-Content -Raw
        if ($assemblyInfo -match 'AssemblyVersion\("([^"]+)"\)') {
          $version = $matches[1]
          echo "version=$version" >> $env:GITHUB_OUTPUT
          Write-Host "ğŸ“¦ AssemblyVersion: $version"
        } else {
          Write-Host "âš ï¸ Keine AssemblyVersion gefunden!"
          exit 1
        }
    - name: ğŸ§© Prepare EXE Artifact
      shell: pwsh
      run: |
        $src = "$env:Output_Dir/${{ matrix.configuration }}"
        $exe = Get-ChildItem $src -Filter "*.exe" | Select-Object -First 1
        $newName = if ("${{ matrix.configuration }}" -eq "Debug") {
          "$($exe.BaseName)_debug.exe"
        } else {
          "$($exe.BaseName).exe"
        }
        Copy-Item $exe.FullName $newName
        echo "exe_name=$newName" >> $env:GITHUB_ENV
        Write-Host "âœ… Prepared $newName"

    - name: â˜ï¸ Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.exe_name }}
        path: ${{ env.exe_name }}
        
  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - name: ğŸ“¦ Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./release-files

    - name: ğŸ§¾ Generate Changelog
      id: changelog
      run: |
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          echo "ğŸ“œ First release, showing all commits."
          COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
        else
          echo "ğŸ“œ Commits since $LAST_TAG:"
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
        fi
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: ğŸ·ï¸ Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.build.outputs.version }}
        name: "Release v${{ needs.build.outputs.version }}"
        body: |
          ## ğŸš€ Version ${{ needs.build.outputs.version }}
          **Release Date:** $(date +"%Y-%m-%d")

          ### ğŸ§¾ Commits since last release:
          ${{ steps.changelog.outputs.changelog }}
        files: ./release-files/**
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
